<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://zdkcloud.top</id>
    <title>Gridea</title>
    <updated>2021-08-25T04:44:48.591Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://zdkcloud.top"/>
    <link rel="self" href="http://zdkcloud.top/atom.xml"/>
    <logo>http://zdkcloud.top/images/avatar.png</logo>
    <icon>http://zdkcloud.top/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[最简单的c++程序]]></title>
        <id>http://zdkcloud.top/post/zui-jian-dan-de-ccheng-xu/</id>
        <link href="http://zdkcloud.top/post/zui-jian-dan-de-ccheng-xu/">
        </link>
        <updated>2021-08-16T08:19:37.000Z</updated>
        <content type="html"><![CDATA[<p>#include <iostream><br>
using namespace std;<br>
int main(){<br>
cout&lt;&lt;&quot;hello,world!&quot;&lt;&lt;endl;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见编译问题]]></title>
        <id>http://zdkcloud.top/post/chang-jian-bian-yi-wen-ti/</id>
        <link href="http://zdkcloud.top/post/chang-jian-bian-yi-wen-ti/">
        </link>
        <updated>2021-08-16T06:48:50.000Z</updated>
        <content type="html"><![CDATA[<p>常见编译问题<br>
一 、背景故事<br>
bug是不少同学在学习编程中必定碰到的,但是每位同学对bug的处理可能是不一样的,比如接下来几类看看你们有没有在其中:</p>
<p>辛辛苦苦花了老长时间才写出来的题目,一运行报错了.怎么办呢.看代码,看了一遍又一遍,运气好看出来了,运气不好就放弃了.<br>
看到题目时有一定的思路,开始做题,很快啊就做出来了,一运行报错,没关系错误提示看的懂,根据提示一下子就解决了,再运行测试,答案不对,郁闷了疯狂的加输出不断测试代码哪里错了,结果辛辛苦苦找到了,一看时间一小时过去了.<br>
对题目思路清晰,在写代码的时候就对代码进行区块化,写一区块就测试一区块,到写完的时候报错的概率可以说是微乎及微,答案出错也一定是题目哪里看漏了,欠缺某一步的考虑.<br>
二 、课程目标<br>
什么是OJ<br>
三 、目标详解<br>
1.什么是OJ<br>
在线判题系统（英语：Online Judge，缩写OJ）是一种在编程竞赛中用来测试参赛程序的在线系统，也可以用于平时练习。许多OJ网站会自发组织一些竞赛。 OJ系统能够编译并执行代码，使用预设的数据对这些程序进行测试。提交的代码一般会在受限的环境下运行，包括时间限制、内存限制、安全限制等。代码的输出会被OJ系统捕获，与标准答案进行比较后返回结果。 OJ网站会对用户进行排名，以用户的提交答案通过数多少或某个题目执行时间快慢为排名依据。 那么对于一个代码进行OJ判断会产生以下结果:</p>
<p>1.1 正确（AC: Accept）<br>
恭喜你,代码不需要任何的改动.</p>
<p>1.2 答案错误（WA: Wrong Answer)<br>
来源一般为审题不清晰导致的遗漏判断或者读错题,也有可能是代码描述错误</p>
<p>1.3 编译错误 （CE: Compile Error Error)<br>
所指的意思就是运行代码会报错,最典型的就是缺失分号和变量未声明.</p>
<p>1.4 格式错误 （PE: Presentation Error)<br>
就是说你答案是对的,但是你输出的时候多了个空格什么的,有一点要注意的是并不是所有OJ都是PE,有些就直接显示WA了</p>
<p>1.5 时间超限 （TLE，Time Limit Exceeded）<br>
就是指代码运行时间过长,错误来源有,死循环,代码未进行优化和选错算法.</p>
<p>1.6 运行时错误 (RE: Runtime Error)<br>
就是指代码在运行时产生了数组下标为负数或者超过数组上限,还有可能就是分母为0.</p>
<p>1.7 内存超限（MLE: Memory Limit Exceed）<br>
基本上是指数组开太大了给你100个空间 结果你用了101个.</p>
<p>那么以上7种就是容易碰到的情况也是我们在写代码时刻要注意的地方，最关键的问题还是属于编译问题，毕竟任何代码的测试编译过关是前提，下面我们着重介绍。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识数据结构]]></title>
        <id>http://zdkcloud.top/post/chu-shi-shu-ju-jie-gou/</id>
        <link href="http://zdkcloud.top/post/chu-shi-shu-ju-jie-gou/">
        </link>
        <updated>2021-08-16T06:46:17.000Z</updated>
        <content type="html"><![CDATA[<p>初识数据结构<br>
一、课程目标<br>
数据结构<br>
常见逻辑结构<br>
常见物理结构<br>
STL标准库<br>
二、目标详解</p>
<ol>
<li>数据结构<br>
数据结构指计算机存储、组织数据的方式，是相互之间存在一种或多种特定关系的数据元素的集合。简单来讲数据结构是以某种特殊的方式存储数据的容器。这种“存储方式”决定了一个数据结构对于某些操作是高效的，而对于其他操作则是低效的。我们需要了解各种数据结构的优劣和原理，才能在处理实际问题时选取最合适的数据结构。</li>
</ol>
<p>数据结构的主要研究内容包含三点：逻辑结构、物理结构、操作。</p>
<p>一般说到的数据结构即为逻辑结构。</p>
<ol start="2">
<li>常见逻辑结构<br>
根据数据元素间关系，逻辑结构基本可分为以下四类：</li>
</ol>
<p>集合结构：结构的数据元素间的关系是“属于同一个集合”。<br>
线性结构：结构的数据元素之间存在着一对一的关系。<br>
树形结构：结构的数据元素之间存在着一对多的关系。<br>
图形结构：结构的数据元素之间存在着多对多的关系，也称网状结构。<br>
3. 常见物理结构<br>
物理结构即数据在计算机中的存储方式，分以下四类：</p>
<p>顺序存储：最基本的存储结构，用一组地址连续的存储单元依次存储线性数据结构的各个数据元素，如数组。 特点：可随机存取；插入和删除要移动元素。</p>
<p>链式存储：在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的,也可以是不连续的）。它不要求逻辑上相邻的元素在物理位置上也相邻，结点间的逻辑关系是由附加的指针字段表示的。如链表。 特点：每个结点由数据域和指针域构成；逻辑相邻不一定物理相邻；插入删除方便；查找结点要慢于顺序存储；存储密度小。</p>
<p>索引存储：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引表由若干索引项组成，如果每个节点在索引表中都有一个索引项，则该索引表就被称为稠密索引。若一组节点在索引表中只对应于一个索引项，则该索引表就成为稀疏索引。索引项的一般形式一般是关键字、地址。常见于数据库中。 特点：检索速度快；索引表占用额外空间。</p>
<p>散列存储：又称哈希（hash）存储，将要存储元素的关键值与存储的物理位置建立联系，直接根据关键值算出要存入的地址。如哈希表（散列表）。 特点：访问速度快。</p>
<ol start="4">
<li>STL标准库<br>
STL，英文全称 standard template library，中文可译为标准模板库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，1998年，STL被定为国际标准，正式成为C++程序库的重要组成部分，因此它可以直接在C++里拿来使用，无需安装。</li>
</ol>
<p>例如－使用STL的vector容器：</p>
<p>#include <vector><br>
STL被组织为下面的13个头文件：<algorithm>、<deque>、<functional>、<iterator>、<array>、<vector>、<list>、&lt;forward_list&gt;、<map>、&lt;unordered_map&gt;、<memory>、<numeric>、<queue>、<set>、&lt;unordered_set&gt;、<stack>、<utility>。</p>
<p>可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分，核心是三个部分：</p>
<p>容器(containers)：管理某类对象用，如队列queue、栈stack、向量vector、集合set、映射map等<br>
算法(algorithm)：作用于容器上的算法，如排序(sort)、搜索(upper_bound、...)、交换(swap)等<br>
迭代器(iterators)：用于遍历容器的元素</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识排序算法]]></title>
        <id>http://zdkcloud.top/post/chu-shi-pai-xu-suan-fa/</id>
        <link href="http://zdkcloud.top/post/chu-shi-pai-xu-suan-fa/">
        </link>
        <updated>2021-08-16T06:44:42.000Z</updated>
        <content type="html"><![CDATA[<p>初识排序算法<br>
一、课程目标<br>
了解排序算法相关概念<br>
了解十大排序算法的原理、优化、复杂度<br>
能手写排序算法代码<br>
二、目标详解<br>
1.相关概念<br>
稳定：如果a原本在b前面，而且a=b，排序之后a仍然在b的前面。<br>
不稳定：如果a原本在b的前面，而且a=b，排序之后 a 可能会出现在 b 的后面。<br>
时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br>
空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。<br>
就地排序：排序算法在原数组中即可完成，不需要额外的空间占用，即空间复杂度为O(1)。<br>
2.排序的分类<br>
2.1 从排序方法来分：</p>
<p>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。冒泡排序、插入排序、选择排序、希尔排序、归并、快速排序、堆排序都是非线性时间比较类排序。</p>
<p>线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。计数排序、桶排序、基数排序是线性时间非比较类排序。</p>
<p>2.2 从稳定性来分：</p>
<p>稳定排序：冒泡排序、插入排序、归并排序、计数排序、基数排序、桶排序</p>
<p>不稳定排序：快速排序、选择排序、堆排序、希尔排序</p>
<p>不稳定的排序也可以改变代码变为稳定排序，但是会多执行不必要的操作</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法复杂度]]></title>
        <id>http://zdkcloud.top/post/suan-fa-fu-za-du/</id>
        <link href="http://zdkcloud.top/post/suan-fa-fu-za-du/">
        </link>
        <updated>2021-08-16T06:30:41.000Z</updated>
        <content type="html"><![CDATA[<p>算法复杂度<br>
一、课程目标<br>
算法的目标<br>
算法复杂度<br>
大O函数<br>
常见大O函数<br>
二、目标详解<br>
1、算法的目标<br>
算法是对问题的解决方案，但一个问题会有很多种算法，通常一个好的算法需要具备以下目标：</p>
<p>正确性：对合法输入、非法输入、边界输入都能正确处理，输出合理的结果。<br>
可读性：算法应该描述清晰，方便阅读、理解和交流。<br>
健壮性：算法应运行一致，对于相同的输入始终输出相同的结果。<br>
高效性：算法应占用最少的cpu和内存得到满足的结果，这通过时间复杂度和空间复杂度进行判定。<br>
2、算法复杂度<br>
算法复杂度用来衡量算法的高效性，简单的说就是：</p>
<p>算法运行的有多快（时间效率）<br>
内存占用的有多少（空间效率）<br>
然而，运行时间和语言、机器、机器的状态、数据量的大小都有关系，不好横向比较，为此通常使用一个时间复杂度（相对度量）的概念来衡量算法有多快。</p>
<p>我们假设其它状态不变，仅当问题规模（数据大小）增长时，指令执行的次数也在增长，那么指令执行次数相对于问题规模来说，会构成一个函数T(n)。</p>
<p>例如－对于以下数组求和的算法1+2+3+...+n：</p>
<p>int sum = 0; //指令数为1<br>
for(int i=0; i&lt;n; i++)<br>
sum += n; //指令数为 n<br>
cout &lt;&lt; n; //指令数为1<br>
显然，总的指令数为T(n) = n + 2</p>
<p>3、大O函数<br>
假设一个算法的T(n) = 4n^3 - 2n + 5</p>
<p>当n越来越大时，对于T(n)增长的贡献来说，最高阶的n^3会占据主导地位，其它项可被忽略。</p>
<p>例如：</p>
<p>n=100时，n^3是n的的1万倍，因此可忽略掉n的贡献。<br>
当n从100变成1000时，n<sup>3会增长1000倍，此时4n</sup>3前面的4也可倍忽略。<br>
我们一般用大O函数来表示最主要的贡献部分：O(T(n)) = O(n^3)，也即算法的时间复杂度。</p>
<p>数学定义：当存在正常数c和某个规模n0，如果对所有的n&gt;=n0，都有f(n) &lt;= c T(n)，则称f(n)为T(n)的大O函数，写成：f(n) = O(T(n))。</p>
<p>4、常见大O函数<br>
函数	名称	例子<br>
O(1)	常数阶	交换算法<br>
O(logn)	对数阶	二分查找算法<br>
O(n)	线性阶	求和算法<br>
O(nlogn)	线性对数阶	快速排序算法<br>
O(n^2)	平方阶	冒泡排序算法<br>
O(n^c)	多项式阶（c&gt;1）	多重循环的算法<br>
O(c^n)	指数阶	汉诺塔问题<br>
O(n!)	阶乘阶	旅行商问题<br>
三、扩展理解－复杂度计算与例子<br>
1、计算方法<br>
对算法（或代码）的指令次数进行计算组成T(n)，只保留最高阶项，然后去掉最高阶项前面的常数。</p>
<p>例如以下代码的T(n) = 3, 时间复杂度为O(1)：</p>
<p>int a=20;<br>
int b = a*3 + 4;<br>
cout &lt;&lt; b;<br>
2、O(n)的例子<br>
输出数组元素：</p>
<p>for(int i=0; i&lt;n; i++)<br>
cout &lt;&lt; a[n] &lt;&lt; &quot; &quot;;<br>
3、 O(logn)的例子<br>
给定n，求2的指数p，使得p &lt;= n &lt; 2p</p>
<p>int p = 1;<br>
while(p &lt; n) {<br>
p *= 2;<br>
}<br>
cout &lt;&lt; p;<br>
4、O(n^2)的例子<br>
打印二维数组：</p>
<p>for(int i=0; i&lt;n; i++) {<br>
for(int j=0; j&lt;n; j++)<br>
cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;<br>
cout &lt;&lt; endl;<br>
}<br>
5、O(nlogn)的例子<br>
for(int i=0; i&lt;n; i++)<br>
for(int j=0; j&lt;n; j *= 2)<br>
...<br>
6、O(2^n) 的例子<br>
汉诺塔问题－代码略。</p>
<p>递归表达式：</p>
<p>将n-1个盘子从A经过C移动到B<br>
将第n个盘子从A移动到C<br>
将n-1个盘子从B经过A移动到C<br>
显然T(n) = 2T(n-1) + 1 = 2(2T(n-2) + 1) + 1 = ....，最高阶项为2<sup>n，即O(2</sup>n)。</p>
<p>7、O(n!)的例子<br>
旅行商问题：从一个城市出发，经过所有城市后返回出发地，求最短的路径。</p>
<p>如果用朴素算法，第一个城市有n种选择，第二个有n-1种选择，依次类推，复杂度为O(n!)。</p>
<p>8、空间复杂度<br>
空间复杂度指算法运行过程种临时所占用的内存大小，例如变量、数组等的开销，规则与时间复杂度一样。</p>
<p>在noi竞赛里，对于内存限制一般为128M（或256M），一般都足够使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[string常用方法]]></title>
        <id>http://zdkcloud.top/post/string-chang-yong-fang-fa/</id>
        <link href="http://zdkcloud.top/post/string-chang-yong-fang-fa/">
        </link>
        <updated>2021-07-21T05:43:28.000Z</updated>
        <content type="html"><![CDATA[<p>string常用方法<br>
一、课程目标<br>
赋值：assign<br>
拼接：push_back、append<br>
查找：find<br>
插入：insert<br>
删除：erase<br>
替换：replace<br>
子串：substr<br>
二、目标详解<br>
1、拼接<br>
1.1 拼接字符<br>
s.push_back(ch)：时间复杂度为O(1)，最适合循环里调用。<br>
s = s + ch：时间复杂度介于O(1)和O(n)之间。<br>
1.2 拼接字符串<br>
s.append(t)：时间复杂度为O(n)。<br>
s = s + t: 时间复杂度为O(n)<br>
2、查找<br>
s.find(t)：在s中查找t，返回t第一个出现的位置，如果找不到返回string::npos（2^64-1）<br>
s.find(t, x): 从第x位开始查找<br>
s.find_first_of(t, x): 从x位置开始找，第一个t里的字符出现的位置。<br>
s.find_first_not_of(t, x)：从x位置开始找，第一个不在t里的字符出现的位置。<br>
s.rfind(t): 从后往前找<br>
s.find_last_of(t, x)：从后往前找，第一个t里的字符<br>
s.find_last_not_of(t, x)：从后往前找，第一个不在t里的字符<br>
s = &quot;hello world!&quot;;<br>
int pos = s.find(&quot;world&quot;); //6<br>
3、插入<br>
s.insert(x, t)：在s的第x位上插入字符串t。</p>
<p>s = &quot;01234&quot;;<br>
s.insert(3, &quot;abc&quot;); //012abc34<br>
注意：x一定要是合法的下标！</p>
<p>4、删除<br>
s.erase(x): 从第x位开始删除到最后<br>
s.erase(x, len)：从第x位开始删除len位<br>
s = &quot;abcdefg&quot;;<br>
s.erase(2, 3); // cde被删除了，剩下abf<br>
注意：x一定要是合法的下标！</p>
<p>5、替换<br>
s.replace(x, len, t)：用t替换s中从x开始长度len的一段子串。</p>
<p>s = &quot;abcdefg&quot;;<br>
s.replace(2, 1, 123); //ab123def：cd被替换成了123<br>
注意：</p>
<p>x -&gt; x+len-1 都要是合法的下标<br>
替换可以换成删除＋插入实现<br>
6、子串<br>
s.substr(x, len)：取出从第x位开始，长度为len 的子串。</p>
<p>s = &quot;abcdefg&quot;;<br>
string s2 = s.substr(3, 2); //s2 -&gt; de<br>
注意：</p>
<p>x一定要是合法的下标。<br>
如果x + len -1越界，则只取合法内容。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[string类]]></title>
        <id>http://zdkcloud.top/post/string-lei/</id>
        <link href="http://zdkcloud.top/post/string-lei/">
        </link>
        <updated>2021-07-21T05:38:38.000Z</updated>
        <content type="html"><![CDATA[<p>一、课程目标<br>
string类<br>
变量声明和实例化<br>
常用运算符<br>
输入输出<br>
下标访问<br>
字符串数组<br>
二、目标详解<br>
1、string类<br>
c语言使用'\0'结束的字符数组来表示字符串，为了更方便的使用字符串，c++中专门提供了一个string类，包含在命名空间std中，类库为cstring。</p>
<p>#include <cstring></p>
<p>string s = &quot;hello world!&quot;;<br>
2、变量声明和实例化<br>
string类型的变量声明和基本类型（int、short、char、bool等）一样：</p>
<p>string s;<br>
但是string是一个类，其变量初始化需要经过实例化，即调用构造函数来初始化。</p>
<p>以下几种典型的实例化方法：</p>
<p>string s(&quot;hello&quot;);  //将c字符串&quot;hello&quot;作为s的值<br>
string s(str1);     //拷贝str1字符串变量的值作为s的值<br>
string s(10, 'a');  //生成10个'a'组成的字符串作为s的值<br>
3、常用运算符<br>
为了更方便的对字符串变量进行操作，string类重载了一些运算符，使用起来更加一致。</p>
<p>string s = &quot;hello world!&quot;;  //赋值<br>
string s2 = s + &quot; 1234&quot;;  //连接成&quot;hello world! 1234&quot;<br>
if (s2 == s1)  //是否相等<br>
4、输入输出<br>
string类型变量的输入，可以使用几种：</p>
<p>cin&gt;&gt;s：遇见空格、tab、回车就停止。<br>
getline(cin, s)：读入一行，遇见回车停止。<br>
getline(cin, s, ch)：读入一行，遇见ch（字符）停止。<br>
如果想输入带空格的语句，使用getline函数。</p>
<p>输出字符串变量跟原来一样，如果想输出地址，使用&amp;地址符。</p>
<p>5、下标访问<br>
string类也提供了下标运算符[]，可以使用下标来访问字符元素。</p>
<p>s = &quot;hello&quot;;<br>
cout &lt;&lt; s[0] &lt;&lt; endl;  //'h'</p>
<p>s[0] = 'H';<br>
cout &lt;&lt; s &lt;&lt; endl; //&quot;Hello&quot;<br>
6、字符串数组<br>
每个元素都是一个字符串，例如：</p>
<p>string color[3] = {&quot;red&quot;, &quot;blue&quot;, &quot;yel</p>
]]></content>
    </entry>
</feed>